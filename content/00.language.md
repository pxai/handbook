# Programación {#program}
This is the intro

## Ruby
Ruby es un lenguaje de programación creado en en 1993 por el japonés Yukihiro Matsumoto , más conocido como Matz. Es un lenguaje interpretado y totalmente orientado a objetos que se caracteriza por la simplicidad de su código, por la productividad y porque los desarrolladores disfrutan utilizándolo.

## Hello World

```ruby
puts "Hello World"
```

## Comentarios
Los comentarios en Ruby pueden ponerse de diferentes maneras.

```ruby
# Esto es un comentario

# puts 'Esto no saldrá'
# Pero esto sí:
puts 'Kaixo'
```
A veces se precisan comentarios más largos de varias líneas. De manera alternativa, en Ruby pueden crearse entre los símbolos =begin y =end.
```ruby
=begin
Horrela ere bai,
kontuz ibili begin eta end
jartzeko
garaian
=end
```
También se admiten comentarios así, de varias líneas
```ruby
"Esto es un comentario
de varias líneas
de extensión"
```
Otra manera de comentar es utilizando estos símbolos
```ruby
Esto es un comentario
DOC
```
También todo aquello que se ponga tras la siguiente marca se considerará como un comentario.
```ruby
__END__
```
En general, si se siguen las buenas prácticas de la comunidad Ruby, los comentarios preferidos son lo que simplemente utilizan las almohadillas, incluso para comentarios de varias líneas.

## Variables
Ruby es un lenguaje interpretado que no necesita que las variables se declaren como un tipo determinado: numérico, cadena, etc.

Las cadenas, textos o strings pueden ir entre comillas dobles o simples.
```ruby
# Palabras
name = 'Eugene'
surname = "Krabs"
```
Al igual que en otros lenguajes, existen determinados caracteres especiales que se aplican con la contrabarra o backslash.

Los números pueden ser enteros, con decimales, y en caso de números grandes, pueden utilizarse los guiones bajos para marcar
```ruby
number = 42
weight = 67.34
salary = 10_000_000
```

Los variables booleanas, solo pueden contener dos valores: true (verdadero) o false (falso).
```ruby
i_will_die = true
i_am_inmortal = false
```
Para mostrar el contenido de una variable en un mensaje, se debe encerrar dentro del símbolo #{}
```ruby
puts "#{number} is the meaning of life"
```

Tambíen se pueden hacer asignaciones múltiples de variables:
```ruby
a, b, c = 0, 3, 2
puts b  # 3
```
Las *constantes* son variables cuyo valor no debe cambiar nunca. En ruby se declaran de forma implícita poniendo, al menos, el primer caracter en mayúscula.
```ruby
Pi = 3.1415
```

Pese a que Ruby no declara los tipos de variables, el lenguaje es fuertemente tipado y en el momento de hacer operaciones
no permitirá operar con variables que contengan tipos incompatibles.
```ruby
weight = 56.73
weight = "hola"
```
### Conversiones
En ocasiones necesitaremos hacer conversiones de tipos. En Ruby disponemos de una serie de métodos que se pueden aplicar a las variables y a las expresiones para hacer esa conversión:
* to_s: convierte a string
* to_i: convierte a número entero

## Entrada/Salida básica
Cuando se hacen programas que se ejecutan en una consola o en un interprete de comandos o en un entorno online como repl.it, se necesitan medios para poder mostrar mensajes al usuario. La forma más directa de mostrar mensajes en Ruby es mediante la instrucción puts

### Entrada de datos
Si lo que se necesitamos es que el programa solicite datos al usuario para escribirlos, utilizamos la instrucción gets. Al meter esta instrucción la ejecución del programa se detiene hasta que el usuario pulse enter. En ese momento, todo lo que haya escrito se almacenará en la variable que se haya especificado, por ejemplo:
```ruby
puts "please tell me your age"
age = gets
puts "You entered #{age}"
```
1- El programa saca un mensaje pidiendo la edad.
2- Mediante gets el programa queda a la espera de que se escriba y una vez se pulsa enter el valor que escribe el usuario se guarda en la variable age.
3- El programa saca un mensaje con el valor de la variable age.

Hay que tomar precauciones al leer datos del usuario:
- Por normal general, no hay que fiarse de lo que escribe el usuario, ya sea por despiste o por maldad.
- En el caso de Ruby, la lectura incluye el caracter enter.
- En el caso de Ruby, lo que see lee se guarda como tipo string.

Si queremos solicitar un dato al usuario y queremos que se guarde directamente como un número, podemos hacer lo siguiente:
```ruby
puts "please tell me your age"
age = gets.chomp.to_i
puts "You entered #{age}"
```
La instrucción chomp corta el último caracter de lo que escribe el usuario (la tecla enter) y to_i lo convierte a entero.
*¡OJO!* si el usuario introduce un valor no numérico, el programa se detendrá.

## Operadores
Los operadores nos permiten realizar distintos tipos de operaciones entre valores, variables y todo tipo de expresiones, siempre que los tipos sean compatibles entre si.
Los operadores en Ruby no se diferencian mucho de la mayoría de lenguajes de programación.

### Aritméticos
```ruby
# +, -, *, /, %, **
a = 10
b = 2
c = 3

result = (a + b) * c   # 36
puts result
a = 2
b = 4
c = a % b

puts a % b             # 2
puts a ** b            # 16

puts 10 / 7            # 1
puts 10.0 / 7          # 1.42857...
puts 10 / 7.0          # 1.42857...
```
En el caso de precisar otros operadores, se puede recurrir a los recursos del lenguaje Ruby.

### Operadores booleanos
Los operadores booleanos básicos son:
- &&: operador _and_, solo si ambos operandos son true el resultado es true.
- ||: operador _or_, basta con que uno de los operandos sea true para que el resultado sea true.
- !: operador _not_, niega el valor booleano y devuelve lo contrario.
```ruby
# &&, ||, !
a = true && true       # true
b = false || true      # true
c = !false             # true

puts b
```

### Operadores de comparación
Los operadores de comparación permiten comparar distintos valores numéricos e incluso cadenas. El resultado de las operaciones de comparación es un valor booleano.
Los operadores son los clásicos:
- ==: igualdad
- !=: desigualdad
- >: mayor que
- >=: mayor o igual que
- <: menor que
- <=: menor o igual que
```ruby
# ==, !=, <, >, <=, >=
emaitza = 5 == 1    # false
emaitza = 5 == '5'  # false
emaitza = 5 == 5.0  # true
emaitza = 5 > 5.0 # false
```
Obviamente, estas expresiones se pueden complicar todo lo que sea necesario utilizando operadores booleanos.
```ruby
age = 18
brothers = 5
discount =  age <= 18 && brothers > 3
```
Al igual que con los operadores aritméticos, las expresiones pueden incluir paréntesis para indicar el orden de las operaciones y facilitar la comprensión de las mismas.


## Condicionales
Bla bla

### If simple
```ruby

puts "Please, enter a number"
number = gets.chomp.to_i    

if number != 0
    puts "it is not 0"
end
```
### If else

```ruby

if number > 0
    puts "It's positive"
else
    puts "It's negative or 0"
end
```
If then
```ruby
result =  if number > 0 then "It's positive"
            else "It's negative or 0"
            end
puts result
```
### If-elsif-else
```ruby
# if-elsif-else
if number > 0
    puts "It's positive"
elsif number < 0
    puts "It's negative"
else
    puts "It's zero"
end
```
bla

### Case When

En ocasiones, se necesita que el programa haga una cosa u otra dependiendo únicamente de el valor de una variable. En casos así, se utiliza una estructura condicional específica a la que se le suele llamar switch/case. En Ruby, a esta estructura se le llama case when.
```
puts "Please, enter an age"
age = gets.chomp.to_i

case
when age < 18
        puts "You are an underage"
when age >= 18 && age < 40
        puts "Millennial detected"
else
        puts "You are an adult"
end
```
Ruby permite una mayor flexibilidad con el tipo de comparaciones que permite hacer.
Un ejemplo un poco más completo, en este caso utilizando la librería date mediante la instrucción require 'date'. Eso nos permitirá tener acceso a utilidades para manejar fechas.
```
require 'date'

puts "Please, enter your name"
name = gets.chomp  

case
when name == "Eugene"
        puts "It's Eugene Krabs"
when name == "Bob"
        puts "It's Spongebob"
when DateTime.now.year == 2018
        puts "It's 2018"
else
        puts "I do not know you"
end
```

## Bucles
Bla bla

```ruby
puts "Hello World"
```
bla
```ruby
puts "Hello World"
```
bla

## Excepciones
Bla bla

```ruby

begin
  puts "Please, enter a number"
  number = gets.chomp.to_i
rescue Exception
    STDERR.puts "Exception: #{$!}"
end
```
bla
```ruby
puts "Please, enter a number"
number = gets.chomp.to_i
begin
    division = 100 / number
rescue ZeroDivisionError
    STDERR.puts "You cannot divide it by 0 #{$!}"
rescue Exception
    STDERR.puts "Exception in division: #{$!}"
    raise   # throws excepction
end
puts "Everything went fine"
puts "You will read this when raise is removed"
```
bla


## arrays
### arrays
```ruby
numbers = []
ages = [45, 78, 21, -67, 0, 10_000]
names = ["Bilbo", "Sam", "Merrin", "Pippin"]
names[0] = "Frodo"

puts "#{ages[1]}"    # 78
puts "#{names[-1]}"    # Pippin
puts "#{ages.length}"  # 6
puts "#{numbers.length}"  # 0
```

### hashes
```ruby
ports = {'http' => 80, 'https' => 443, 'imap' => 143}
puts ports['http']
ports['pop'] = 110

```
También se pueden utilizar símbolos en lugar de cadenas
```ruby
ports2 = {:http => 80, :https => 443, :imap => 143}
puts ports2[:http]
ports2[:pop] = 110

```
Y por supuesto, los hashes se pueden anidar con otros hashes o incluso arrays.
```ruby
heroes = {'Legolas' => {'age' => 1324, 'race'=>'Elf'},
            'Aragorn' => {'age' => 443, 'race'=>'Dunedain'},
            'Gimli' => {'age' => 105, 'race'=>'Dwarf'}}

puts heroes
puts heroes['Legolas']['age'].to_s

```

## Métodos
Bla bla

```ruby
puts "Hello World"
```
bla
```ruby
puts "Hello World"
```
bla

## Clases
Bla bla

```ruby
puts "Hello World"
```
bla
```ruby
puts "Hello World"
```
bla

## Programación orientada a objetos
Bla bla

```ruby
puts "Hello World"
```
bla
```ruby
puts "Hello World"
```
bla
